
-- Use this section to add basic types and
-- constructors for error correcting codes

ZeroCode = new Type of HashTable

zeroCode = method()
zeroCode(GaloisField,ZZ) := ZeroCode =>(F,n)->(
    -- Generates the zero code in F^n
    -- check n is positive
    
    if n >0 then {    
    	GenMat := matrix {apply(toList(0..n-1),i->0)};
    	GenRow := {{}};
    	ParMat := generators F^n;
    	ParRows := entries ParMat;
    	return new ZeroCode from {
            symbol AmbientModule => F^n,
	    symbol BaseField => F,
            symbol Generators => GenRow,
	    symbol GeneratorMatrix => GenMat,
	    symbol ParityCheckMatrix =>  ParMat,
	    symbol ParityCheckRows  => ParRows,
	    symbol cache => {}
	    }
    } else {
    error "The length of the code should be positive."
    };

  )


UniverseCode = new Type of HashTable

universeCode = method()
universeCode(GaloisField,ZZ) := UniverseCode => (F,n) -> (
    -- construct the universe code F^n
    -- check n is positive
    if n>0 then {
	GenMat := generators F^n;
    	GenRow := entries GenMat;
    	ParMat := matrix {apply(toList(0..n-1),i->0)};
    	ParRows := {{}};
    	return new UniverseCode from {
            symbol AmbientModule => F^n,
	    symbol BaseField => F,
            symbol Generators => GenRow,
	    symbol GeneratorMatrix => GenMat,
	    symbol ParityCheckMatrix =>  ParMat,
	    symbol ParityCheckRows  => ParRows,
	    symbol cache => {}
	    }	
	} else {
	error "The length of the code should be positive."
	};    
    )
 
-- internal function to validate user's input
wellDefinedInput  = method(TypicalValue => List)

wellDefinedInput(List) :=  UserInput -> (
    -- user's input is used to create a list
    -- UserInput={GaloisField, lengthCode, ListGenerators}
    
    -- check if "baseField" is a Galois field, throw an error otherwise:
    if not isField UserInput_0 then error "Codes over non-Galois fields are not defined yet in this version";
    
    if UserInput_2 != {} then {
    	-- check that the length of all generating codewords equals the rank of AmbienModule:
    	if not all(UserInput_2,codeword -> (length codeword) == UserInput_1) then {
	    error "Expected codewords all to be the same length and equal to the rank of the Module";
	    } 
	else {
	    -- coerce generators into base field, if possible:
	    return try apply(UserInput_2, codeword -> apply(codeword, entry -> sub(entry, UserInput_0)))
	     else {
	    error "Entries of codewords do not live in base field/ring.";
	    }
	   }
	} else {
	return  {UserInput_2}
	};
  )


LinearCode = new Type of HashTable

-- internal function to construct a linear code
builtLinearCode = method()
builtLinearCode(List) := LinearCode => (inputVec) -> (
    -- use externally facing functions to create list
    -- input: {AmbientModule, BaseField, lengthCode, Generators, ParityCheckRows, Code}
    -- output: linear code generated by Generators or ParityCheckRows or submodule converted into a code
       
     if inputVec_3 != {} then {
	  if # (inputVec_3)_0 == 0 then {
	     -- generator matrix is zero so the code is the zero code
	     return zeroCode(inputVec_1, inputVec_2)
	     }
	  else {
	     -- Generators do not generate the zero code
	     -- construct the generator matrix with entries in BaseField
             G = matrix apply(inputVec_3, codewords -> apply(codewords,entry -> sub(entry,inputVec_1)));
	     -- reduced form of the generator matrix
	     GenMat = transpose groebnerBasis transpose G;
	     if rank GenMat == inputVec_2 then {
		 -- generatos generate the universe code R^n
		 return universeCode(inputVec_1, inputVec_2)
		 }
	     else {
		 -- generators yield a subspace of R^n
		 GenRow = entries GenMat;
    	     	 codeSpace = image transpose GenMat;
		 rawParMat = transpose generators kernel GenMat; 
		 ParMat = transpose groebnerBasis transpose rawParMat;
 	    	 ParRow = entries ParMat;
		 return new LinearCode from {
        	    symbol AmbientModule => inputVec_0,
		    symbol BaseField => inputVec_1,
		    symbol Code => codeSpace,
        	    symbol GeneratorMatrix => GenMat,
		    symbol Generators => GenRow,
		    symbol ParityCheckMatrix =>  ParMat,
		    symbol ParityCheckRows  => ParRow,
		    symbol cache => {}
		    }
		 }
	     }
	 };

	 
    if inputVec_4 != {} then {
	if # (inputVec_4)_0 == 0 then {
	    -- ParityCheck rows generate the zero code, so the code is the universe code
	    return universeCode(inputVec_1,inputVec_2)
	    }
	else {
	    -- ParityCheck rows do no generate the zero code
	    --construct the parity check matrix with entries in BaseField
	    P = matrix apply(inputVec_4, codewords -> apply(codewords,entry -> sub(entry,inputVec_1))); 
	    -- reduced form of the paritycheck matrix
	    ParMat = transpose groebnerBasis transpose P;
	    if rank ParMat == inputVec_2 then {
		-- the dual code is the universe code, so the code is the zero code
		return zeroCode(inputVec_1,inputVec_2)
		}
	    else {
		-- dual code is a subspace of R^n
		ParRow = entries ParMat;
		rawGen = transpose generators kernel ParMat;
	    	GenMat = transpose groebnerBasis transpose rawGen;
		GenRow = entries GenMat;
		codeSpace = image transpose GenMat;
		return new LinearCode from {
        	    symbol AmbientModule => inputVec_0,
		    symbol BaseField => inputVec_1,
        	    symbol Code => codeSpace,
		    symbol GeneratorMatrix => GenMat,
		    symbol Generators => GenRow,
		    symbol ParityCheckMatrix =>  ParMat,
		    symbol ParityCheckRows  => ParRow,
		    symbol cache => {}
		    }
	     };
	};
    };
    
    if inputVec_5 != {} then {
    	-- coerce code matrix into base field:
    	codeSpace := sub(inputVec_4,inputVec_1);
	
	return new LinearCode from {
        symbol AmbientModule => inputVec_0,
	symbol BaseField => inputVec_1,
        symbol Generators => GenRow,
	symbol GeneratorMatrix => GenMat,
	symbol ParityCheckRows  => ParRow,
	symbol ParityCheckMatrix =>  ParMat,
	symbol Code => codeSpace,
	symbol cache => {}
	}
    };
   
  )

-- by default, assume that inputs are generators or generating matrices
-- set ParityCheck => true to have inputs be rows of parity check matrix:
linearCode = method(Options => {symbol ParityCheck => false})

linearCode(Module,List) := LinearCode => opts -> (M,L) -> (
    -- constructor for a linear code
    -- input: ambient Module M, list of generating codewords
    -- outputs: code defined by submodule given by span of elements in L
    
    --  validate user's input creating a list
    -- {GaloisField,lengthCode,ListGenerators}
        
    newL := wellDefinedInput {M.ring,rank M,L};
    
   if opts.ParityCheck then {
     --{AmbienModule,BaseField,lengthCode,Generators,ParityCheckRows,Code}
     outputVec = {M, M.ring, rank M, {}, newL, {}};
    }
   else {
     --{AmbienModule,BaseField,lengthCode,Generators,ParityCheckRows,Code}
     outputVec =  {M, M.ring, rank M, newL , {}, {}};
     };
    
     return builtLinearCode(outputVec)
    )

linearCode(GaloisField,ZZ,List) := LinearCode => opts -> (F,n,L) -> (
    -- input: field, ambient dimension, list of generating codewords
    -- outputs: code defined by module given by span of elements in L   
   
   
    --  validate user's input creating a list
    -- {GaloisField,lengthCode,ListGenerators}
   
    newL := wellDefinedInput {F,n,L};
  
    
   if opts.ParityCheck then {
     --{AmbienModule,BaseField,lengthCode,Generators,ParityCheckRows,Code}
     outputVec = {F^n, F, n, {}, newL, {}};
    }
   else {
     --{AmbienModule,BaseField,lengthCode,Generators,ParityCheckRows,Code}
     outputVec =  {F^n, F, n, newL , {}, {}};
     };
    
     return builtLinearCode(outputVec)
   )

linearCode(GaloisField,List) := LinearCode => opts -> (F,L) -> (
    -- input: field, list of generating codewords
    -- outputs: code defined by module given by span of elements in L
    
    -- calculate length of code via elements of L:
    n := # L_0;
    
    --  validate user's input creating a list
    -- {GaloisField,lengthCode,ListGenerators}
   
    newL := wellDefinedInput {F,n,L};
    
    if opts.ParityCheck then {
     --{AmbienModule,BaseField,lengthCode,Generators,ParityCheckRows,Code}
     outputVec = {F^n, F, n, {}, newL, {}};
    }
   else {
     --{AmbienModule,BaseField,lengthCode,Generators,ParityCheckRows,Code}
     outputVec =  {F^n, F, n, newL , {}, {}};
     };
    
     return builtLinearCode(outputVec)
     
)


linearCode(ZZ,ZZ,ZZ,List) := LinearCode => opts -> (p,q,n,L) -> (
    -- Constructor for codes over Galois fields
    -- input: prime p, exponent q, dimension n, list of generating codewords L
    -- output: code defined by module given by span of elements in L
       
    --  validate user's input creating a list
    -- {GaloisField,lengthCode,ListGenerators}
   
    newL := wellDefinedInput {GF(p,q),n,L};
    
    
    if opts.ParityCheck then {
     --{AmbienModule,BaseField,lengthCode,Generators,ParityCheckRows,Code}
     outputVec = {F^n, F, n, {}, newL, {}};
    }
   else {
     --{AmbienModule,BaseField,lengthCode,Generators,ParityCheckRows,Code}
     outputVec =  {F^n, F, n, newL , {}, {}};
     };
    
     return builtLinearCode(outputVec)
       
   )


linearCode(Module) := LinearCode => opts -> V -> (
    -- constructor for a linear code
    -- input: some submodule V of S
    -- outputs: code defined by submodule V    
    
    -- produce a set of generators for the specified submodule V:
    generatorMatrix := transpose generators V;
    
    --  validate user's input creating a list
    -- {GaloisField,lengthCode,ListGenerators}
    L:=entries generatorMatrix;
    n:= # L_0;
       
    newL := wellDefinedInput {generatorMatrix.ring, n, L};
    
    
    if opts.ParityCheck then {
     --{AmbienModule,BaseField,lengthCode,Generators,ParityCheckRows,Code}
     outputVec = {generatorMatrix.source, generatorMatrix.ring, n, {}, newL, {}};
    }
   else {
     --{AmbienModule,BaseField,lengthCode,Generators,ParityCheckRows,Code}
     outputVec =  {generatorMatrix.source, generatorMatrix.ring, n, newL , {}, {}};
     };
    
     return builtLinearCode(outputVec)
    
    )

linearCode(Matrix) := LinearCode => opts -> M -> (
    -- constructor for a linear code
    -- input: a generating matrix for a code
    -- output: if ParityCheck => true then code defined by kernel of M
    --         if ParityCheck => false then code defined by rows of M
        
    --  validate user's input creating a list
    -- {GaloisField,lengthCode,ListGenerators}
    L:=entries M;
    n:= # L_0;
       
    newL := wellDefinedInput {M.ring, n, L};
        

    if opts.ParityCheck then {
	--{AmbienModule,BaseField,lengthCode,Generators,ParityCheckRows,Code}
	outputVec := {M.source, M.ring, n, {}, L, {}};
	} else {
	outputVec =  {M.source, M.ring, n, L, {}, {}};
	};      
    )















