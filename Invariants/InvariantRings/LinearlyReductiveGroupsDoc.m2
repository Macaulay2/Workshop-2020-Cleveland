document {
	Key => {actionMatrix, (actionMatrix, LinearlyReductiveAction)},
	
	Headline => "matrix of a linearly reductive action",
	
	Usage => "actionMatrix V",
	
	Inputs => {
	        "V" => LinearlyReductiveAction => {"on a polynomial ring ", TT "R"},
		},
	    
	Outputs => {
		Matrix => {"the matrix of the action on ", TT "R"}
		},
	    
	"This function is provided by the package ", TO InvariantRings,
	".",
	
	PARA { 
	    "Suppose the action ", TT "V", " consists of the linearly
	    reductive group ", TEX ///Spec$(S/I)$///, " acting on 
	    the polynomial ring ", TT "R", " via the action matrix ",
	    TT "M", ". This function returns the action matrix ", TT "M",
	    ".",
	    },
	EXAMPLE {
		"S = QQ[z]",
		"I = ideal(z^2 - 1)",
		"M = matrix{{(z+1)/2, (1-z)/2},{(1-z)/2, (z+1)/2}}",
		"R = QQ[x,y]",
		"V = linearlyReductiveAction(I, M, R)",
		"actionMatrix V",
		},
	    }

document {
	Key => {groupIdeal, (groupIdeal, LinearlyReductiveAction)},
	
	Headline => "ideal defining a linearly reductive group",
	
	Usage => "groupIdeal V",
	
	Inputs => {
	        "V" => LinearlyReductiveAction => {"of a group ", TEX ///Spec$(S/I)$///},
		},
	    
	Outputs => {
		Ideal => {TT "I"}
		},
	    
	"This function is provided by the package ", TO InvariantRings,
	".",
	
	PARA { 
	    "Suppose the action ", TT "V", " consists of the linearly
	    reductive group ", TEX ///Spec$(S/I)$///, " acting on 
	    the polynomial ring ", TT "R", " via the action matrix ",
	    TT "M", ". This function returns the ideal ", TT "I",
	    ".",
	    },
	EXAMPLE {
		"S = QQ[z]",
		"I = ideal(z^2 - 1)",
		"M = matrix{{(z+1)/2, (1-z)/2},{(1-z)/2, (z+1)/2}}",
		"R = QQ[x,y]",
		"V = linearlyReductiveAction(I, M, R)",
		"groupIdeal V",
		},
	    }



document {
	Key => {hilbertIdeal, (hilbertIdeal, LinearlyReductiveAction)},
	
	Headline => "compute (possibly non-invariant) generators for the Hilbert ideal",
	
	Usage => "hilbertIdeal V",
	
	Inputs => {
	        "V" => LinearlyReductiveAction => {"of a polynomial ring ", TT "S", " defining the group as an affine variety"},
		},
	    
	Outputs => {
		Ideal => {"the ideal of ", TT "R", " generated by the invariants (note that the generators of I are likely non-invariant)"}
		},
	    
	"This function is provided by the package ", TO InvariantRings,
	".",
	
	PARA { 
	    "This function computes the Hilbert ideal generated in a polynomial ring by the 
	    invariants of positive degree of a linearly reductive action.  The algorithm is
	    based on: ",
	    },
       	
	UL { 
	    {"Derksen, H. & Kemper, G. (2015).", EM " Computational Invariant Theory", 
	   ". Heidelberg: Springer. pp 159-164"}
        },
	
	PARA {
	    "The hope is that this function will be used to compute actual generating invariants, 
	    but the crucial step of the Reynolds operator is still missing."
	    },
	
	
	PARA {
	    "The next example constructs a cyclic group of order 2
	    as a set of two affine points. Then it introduces an
	    action of this group on a polynomial ring in two variables
	    and computes the Hilbert ideal. The action permutes the
	    variables of the polynomial ring. Note that the
	    generators of the Hilbert ideal need not be invariant."
	    },
	
	EXAMPLE {
		"S = QQ[z]",
		"A = ideal(z^2 - 1)",
		"M = matrix{{(z+1)/2, (1-z)/2},{(1-z)/2, (z+1)/2}}",
		"sub(M,z=>1),sub(M,z=>-1)",
		"R = QQ[x,y]",
		"V = linearlyReductiveAction(A, M, R)",
		"I = hilbertIdeal V",
		"apply(I_*, f -> isInvariant(f,V))"
		},
	    }


document {
	Key => {linearlyReductiveAction, (linearlyReductiveAction, Ideal, Matrix, PolynomialRing)},
	
	Headline => "Linearly reductive group action",
	
	Usage => "linearlyReductiveAction(I, M, R)",
	
	Inputs => {
	        "I" => Ideal => {"of a polynomial ring ", TT "S", " defining a group as an affine variety"},
		"M" => Matrix => {"whose entries are in ", TT "S", ", that encodes the group action on ", TT "R"},
	    	"R" => PolynomialRing => {"on which the group acts"},
		},
	    
	Outputs => {
		LinearlyReductiveAction => {"the linearly reductive action of ", TT "S/I",
		    " on ", TT "R", " via the matrix ", TT "M"}
		},
	    
	"This function is provided by the package ", TO InvariantRings, ".",
    
    	PARA {
	    "In order to encode a linearly reductive group action,
	    we represent the group as an affine variety.
	    The affine space containing the group has coordinate
	    ring ", TT "S", " and the elements of the group are
	    the points in the vanishing locus of an ideal ",
	    TT "I", " of ", TT "S", ". The group acts linearly on the
	    polynomial ring ", TT "R", " via the matrix ",
	    TT "M", " with entries in ", TT "S", ".",
	},
	PARA {
	    "The next example constructs a cyclic group of order 2
	    as a set of two affine points. Then it introduces an
	    action of this group on a polynomial ring in two variables."
	    },
	EXAMPLE {
		"S = QQ[z]",
		"I = ideal(z^2 - 1)",
		"M = matrix{{(z+1)/2, (1-z)/2},{(1-z)/2, (z+1)/2}}",
		"sub(M,z=>1),sub(M,z=>-1)",
		"R = QQ[x,y]",
		"V = linearlyReductiveAction(I, M, R)",
		},
}


document {
	Key => {LinearlyReductiveAction},
	
	Headline => "the class of all (non finite, non toric) linearly reductive group actions",
	
	"This class is provided by the package ", TO InvariantRings,".",
	
	PARA {
	    	TT "TorusAction", " is the class of all
		linearly reductive group actions on polynomial ring
		for the	purpose of computing invariants.
		It is created using ", TO "linearlyReductiveAction", ".",
		" This class should not be used for actions of
		tori or finite groups, as its methods for computing
		invariants are in general less efficient than
		specialized methods for the classes ", TO "TorusAction", ", ",
		TO "FiniteGroupAction", ", and ", TO "FiniteAbelianAction", "."
	    },
	}





